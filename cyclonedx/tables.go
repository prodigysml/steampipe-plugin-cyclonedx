package cyclonedx

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/turbot/steampipe-plugin-sdk/v5/grpc/proto"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"io/ioutil"
	"os"
	"path/filepath"
	"time"
)

// AutoGenerated defines the structure to match your JSON format
type AutoGenerated struct {
	BomFormat    string `json:"bomFormat"`
	SpecVersion  string `json:"specVersion"`
	SerialNumber string `json:"serialNumber"`
	Version      int    `json:"version"`
	Metadata     struct {
		Timestamp time.Time `json:"timestamp"`
		Tools     struct {
			Components []struct {
				Group     string `json:"group"`
				Name      string `json:"name"`
				Version   string `json:"version"`
				Purl      string `json:"purl"`
				Type      string `json:"type"`
				BomRef    string `json:"bom-ref"`
				Author    string `json:"author"`
				Publisher string `json:"publisher"`
			} `json:"components"`
		} `json:"tools"`
		Authors []struct {
			Name string `json:"name"`
		} `json:"authors"`
		Lifecycles []struct {
			Phase string `json:"phase"`
		} `json:"lifecycles"`
		Component struct {
			Group      string `json:"group"`
			Name       string `json:"name"`
			Version    string `json:"version"`
			Purl       string `json:"purl"`
			BomRef     string `json:"bom-ref"`
			Scope      string `json:"scope"`
			Properties []struct {
				Name  string `json:"name"`
				Value string `json:"value"`
			} `json:"properties"`
			Type string `json:"type"`
		} `json:"component"`
		Properties []struct {
			Name  string `json:"name"`
			Value string `json:"value"`
		} `json:"properties"`
	} `json:"metadata"`
	Components []struct {
		Group   string `json:"group"`
		Name    string `json:"name"`
		Version string `json:"version"`
		Scope   string `json:"scope,omitempty"`
		Hashes  []struct {
			Alg     string `json:"alg"`
			Content string `json:"content"`
		} `json:"hashes,omitempty"`
		Purl       string `json:"purl"`
		Type       string `json:"type"`
		BomRef     string `json:"bom-ref"`
		Properties []struct {
			Name  string `json:"name"`
			Value string `json:"value"`
		} `json:"properties"`
		Licenses []struct {
			License struct {
				ID string `json:"id"`
			} `json:"license"`
		} `json:"licenses,omitempty"`
		Evidence struct {
			Identity struct {
				Field      string `json:"field"`
				Confidence int    `json:"confidence"`
				Methods    []struct {
					Technique  string `json:"technique"`
					Confidence int    `json:"confidence"`
					Value      string `json:"value"`
				} `json:"methods"`
			} `json:"identity"`
		} `json:"evidence,omitempty"`
	} `json:"components"`
	Dependencies []struct {
		Ref       string `json:"ref"`
		DependsOn []any  `json:"dependsOn"`
	} `json:"dependencies"`
}

// Helper function to find all JSON files in the directory
func findJSONFiles(directory string) ([]string, error) {
	var files []string
	err := filepath.Walk(directory, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && filepath.Ext(path) == ".json" {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

// Helper function to parse a JSON file into the AutoGenerated struct
func parseJSONFile(filename string) (*AutoGenerated, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	data, err := ioutil.ReadAll(file)
	if err != nil {
		return nil, err
	}

	var bom AutoGenerated
	err = json.Unmarshal(data, &bom)
	if err != nil {
		return nil, err
	}
	return &bom, nil
}

// Reusable function to process and stream BOM data with both counters
func processAndStreamBOMData(ctx context.Context, d *plugin.QueryData, directory string, extractor func(bom AutoGenerated, fileCounter int, metadataCounter int, filePath string) []map[string]interface{}) error {
	// Find all JSON files in the directory
	files, err := findJSONFiles(directory)
	if err != nil {
		fmt.Printf("Error finding JSON files: %v\n", err)
		return err
	}

	fileCounter := 1

	// Parse each JSON file and extract the necessary data
	for _, file := range files {
		bomData, err := parseJSONFile(file)
		if err != nil {
			fmt.Printf("Error parsing JSON file %s: %v\n", file, err)
			continue
		}

		metadataCounter := 1

		// Assuming each file might have multiple metadata entries
		data := extractor(*bomData, fileCounter, metadataCounter, file)
		metadataCounter++

		for _, item := range data {
			// Stream the extracted data to Steampipe
			d.StreamListItem(ctx, item)
		}

		fileCounter++
	}

	return nil
}

// cyclonedx_bom_info Table Definition and List Function
func tableCyclonedxBomInfo(ctx context.Context, tableName string) *plugin.Table {
	return &plugin.Table{
		Name:        tableName,
		Description: "Details of BOM info files.",
		List: &plugin.ListConfig{
			Hydrate: listCyclonedxBomInfo,
			KeyColumns: []*plugin.KeyColumn{
				{Name: "directory", Require: plugin.Optional},
			},
		},
		Columns: []*plugin.Column{
			{Name: "id", Type: proto.ColumnType_INT, Description: "ID of the BOM entry."},
			{Name: "directory", Type: proto.ColumnType_STRING, Description: "Directory where JSON files are located."},
			{Name: "file_path", Type: proto.ColumnType_STRING, Description: "The full path to the JSON file."},
			{Name: "bom_format", Type: proto.ColumnType_STRING, Description: "Format of the BOM."},
			{Name: "spec_version", Type: proto.ColumnType_STRING, Description: "Specification version."},
			{Name: "serial_number", Type: proto.ColumnType_STRING, Description: "Serial number of the BOM."},
			{Name: "version", Type: proto.ColumnType_INT, Description: "Version of the BOM."},
		},
	}
}

func getDirectory(d *plugin.QueryData) string {
	quals := d.EqualsQuals
	directory := quals["directory"].GetStringValue()
	if directory == "" {
		directory = "./examples"
	}

	return directory
}

func listCyclonedxBomInfo(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	// Get the directory from the query or use default
	directory := getDirectory(d)

	return processAndStreamBOMData(ctx, d, directory, func(bom AutoGenerated, fileCounter, metadataCounter int, filePath string) []map[string]interface{} {
		return []map[string]interface{}{
			{
				"id":            fileCounter,
				"directory":     directory,
				"file_path":     filePath,
				"bom_format":    bom.BomFormat,
				"spec_version":  bom.SpecVersion,
				"serial_number": bom.SerialNumber,
				"version":       bom.Version,
			},
		}
	}), nil
}

// cyclonedx_metadata Table Definition and List Function
func tableCyclonedxMetadata(ctx context.Context, tableName string) *plugin.Table {
	return &plugin.Table{
		Name:        tableName,
		Description: "Metadata details from the BOM files.",
		List: &plugin.ListConfig{
			Hydrate: listCyclonedxMetadata,
			KeyColumns: []*plugin.KeyColumn{
				{Name: "directory", Require: plugin.Optional},
			},
		},
		Columns: []*plugin.Column{
			{Name: "id", Type: proto.ColumnType_INT, Description: "ID of the metadata entry."},
			{Name: "file_id", Type: proto.ColumnType_INT, Description: "ID of the associated BOM file."},
			{Name: "metadata_counter", Type: proto.ColumnType_INT, Description: "Counter for metadata entries within the file."},
			{Name: "directory", Type: proto.ColumnType_STRING, Description: "Directory where JSON files are located."},
			{Name: "timestamp", Type: proto.ColumnType_TIMESTAMP, Description: "Timestamp of the metadata."},
		},
	}
}

func listCyclonedxMetadata(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	// Get the directory from the query or use default
	directory := getDirectory(d)

	return processAndStreamBOMData(ctx, d, directory, func(bom AutoGenerated, fileCounter, metadataCounter int, filePath string) []map[string]interface{} {
		return []map[string]interface{}{
			{
				"id":               metadataCounter,
				"file_id":          fileCounter,
				"metadata_counter": metadataCounter,
				"directory":        directory,
				"timestamp":        bom.Metadata.Timestamp,
			},
		}
	}), nil
}

// cyclonedx_tools Table Definition and List Function
func tableCyclonedxTools(ctx context.Context, tableName string) *plugin.Table {
	return &plugin.Table{
		Name:        tableName,
		Description: "Tools used in the BOM files.",
		List: &plugin.ListConfig{
			Hydrate: listCyclonedxTools,
			KeyColumns: []*plugin.KeyColumn{
				{Name: "directory", Require: plugin.Optional},
			},
		},
		Columns: []*plugin.Column{
			{Name: "id", Type: proto.ColumnType_INT, Description: "ID of the tool entry."},
			{Name: "file_id", Type: proto.ColumnType_INT, Description: "ID of the associated BOM file."},
			{Name: "directory", Type: proto.ColumnType_STRING, Description: "Directory where JSON files are located."},
			{Name: "group_name", Type: proto.ColumnType_STRING, Description: "Group name of the tool."},
			{Name: "name", Type: proto.ColumnType_STRING, Description: "Name of the tool."},
			{Name: "version", Type: proto.ColumnType_STRING, Description: "Version of the tool."},
			{Name: "purl", Type: proto.ColumnType_STRING, Description: "Package URL of the tool."},
			{Name: "type", Type: proto.ColumnType_STRING, Description: "Type of the tool."},
			{Name: "bom_ref", Type: proto.ColumnType_STRING, Description: "BOM reference of the tool."},
			{Name: "author", Type: proto.ColumnType_STRING, Description: "Author of the tool."},
			{Name: "publisher", Type: proto.ColumnType_STRING, Description: "Publisher of the tool."},
		},
	}
}

func listCyclonedxTools(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	// Get the directory from the query or use default
	directory := getDirectory(d)

	return processAndStreamBOMData(ctx, d, directory, func(bom AutoGenerated, fileCounter, metadataCounter int, filePath string) []map[string]interface{} {
		var results []map[string]interface{}

		for _, tool := range bom.Metadata.Tools.Components {
			results = append(results, map[string]interface{}{
				"id":         metadataCounter,
				"file_id":    fileCounter,
				"directory":  directory,
				"group_name": tool.Group,
				"name":       tool.Name,
				"version":    tool.Version,
				"purl":       tool.Purl,
				"type":       tool.Type,
				"bom_ref":    tool.BomRef,
				"author":     tool.Author,
				"publisher":  tool.Publisher,
			})
			metadataCounter++
		}

		return results
	}), nil
}

// cyclonedx_authors Table Definition and List Function
func tableCyclonedxAuthors(ctx context.Context, tableName string) *plugin.Table {
	return &plugin.Table{
		Name:        tableName,
		Description: "Authors of the BOM files.",
		List: &plugin.ListConfig{
			Hydrate: listCyclonedxAuthors,
			KeyColumns: []*plugin.KeyColumn{
				{Name: "directory", Require: plugin.Optional},
			},
		},
		Columns: []*plugin.Column{
			{Name: "id", Type: proto.ColumnType_INT, Description: "ID of the author entry."},
			{Name: "file_id", Type: proto.ColumnType_INT, Description: "ID of the associated BOM file."},
			{Name: "directory", Type: proto.ColumnType_STRING, Description: "Directory where JSON files are located."},
			{Name: "name", Type: proto.ColumnType_STRING, Description: "Name of the author."},
		},
	}
}

func listCyclonedxAuthors(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	// Get the directory from the query or use default
	directory := getDirectory(d)

	return processAndStreamBOMData(ctx, d, directory, func(bom AutoGenerated, fileCounter, metadataCounter int, filePath string) []map[string]interface{} {
		var results []map[string]interface{}

		for _, author := range bom.Metadata.Authors {
			results = append(results, map[string]interface{}{
				"id":        metadataCounter,
				"file_id":   fileCounter,
				"directory": directory,
				"name":      author.Name,
			})
			metadataCounter++
		}

		return results
	}), nil
}

// cyclonedx_lifecycles Table Definition and List Function
func tableCyclonedxLifecycles(ctx context.Context, tableName string) *plugin.Table {
	return &plugin.Table{
		Name:        tableName,
		Description: "Lifecycles associated with the BOM files.",
		List: &plugin.ListConfig{
			Hydrate: listCyclonedxLifecycles,
			KeyColumns: []*plugin.KeyColumn{
				{Name: "directory", Require: plugin.Optional},
			},
		},
		Columns: []*plugin.Column{
			{Name: "id", Type: proto.ColumnType_INT, Description: "ID of the lifecycle entry."},
			{Name: "file_id", Type: proto.ColumnType_INT, Description: "ID of the associated BOM file."},
			{Name: "directory", Type: proto.ColumnType_STRING, Description: "Directory where JSON files are located."},
			{Name: "phase", Type: proto.ColumnType_STRING, Description: "Lifecycle phase."},
		},
	}
}

func listCyclonedxLifecycles(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	// Get the directory from the query or use default
	directory := getDirectory(d)

	return processAndStreamBOMData(ctx, d, directory, func(bom AutoGenerated, fileCounter, metadataCounter int, filePath string) []map[string]interface{} {
		var results []map[string]interface{}

		for _, lifecycle := range bom.Metadata.Lifecycles {
			results = append(results, map[string]interface{}{
				"id":        metadataCounter,
				"file_id":   fileCounter,
				"directory": directory,
				"phase":     lifecycle.Phase,
			})
			metadataCounter++
		}

		return results
	}), nil
}

// cyclonedx_components Table Definition and List Function
func tableCyclonedxComponents(ctx context.Context, tableName string) *plugin.Table {
	return &plugin.Table{
		Name:        tableName,
		Description: "Components within the BOM files.",
		List: &plugin.ListConfig{
			Hydrate: listCyclonedxComponents,
			KeyColumns: []*plugin.KeyColumn{
				{Name: "directory", Require: plugin.Optional},
			},
		},
		Columns: []*plugin.Column{
			{Name: "id", Type: proto.ColumnType_INT, Description: "ID of the component entry."},
			{Name: "file_id", Type: proto.ColumnType_INT, Description: "ID of the associated BOM file."},
			{Name: "directory", Type: proto.ColumnType_STRING, Description: "Directory where JSON files are located."},
			{Name: "group_name", Type: proto.ColumnType_STRING, Description: "Group name of the component."},
			{Name: "name", Type: proto.ColumnType_STRING, Description: "Name of the component."},
			{Name: "version", Type: proto.ColumnType_STRING, Description: "Version of the component."},
			{Name: "scope", Type: proto.ColumnType_STRING, Description: "Scope of the component."},
			{Name: "purl", Type: proto.ColumnType_STRING, Description: "Package URL of the component."},
			{Name: "type", Type: proto.ColumnType_STRING, Description: "Type of the component."},
			{Name: "bom_ref", Type: proto.ColumnType_STRING, Description: "BOM reference of the component."},
		},
	}
}

func listCyclonedxComponents(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	// Get the directory from the query or use default
	directory := getDirectory(d)

	return processAndStreamBOMData(ctx, d, directory, func(bom AutoGenerated, fileCounter, metadataCounter int, filePath string) []map[string]interface{} {
		var results []map[string]interface{}

		for _, component := range bom.Components {
			results = append(results, map[string]interface{}{
				"id":         metadataCounter,
				"file_id":    fileCounter,
				"directory":  directory,
				"group_name": component.Group,
				"name":       component.Name,
				"version":    component.Version,
				"scope":      component.Scope,
				"purl":       component.Purl,
				"type":       component.Type,
				"bom_ref":    component.BomRef,
			})
			metadataCounter++
		}

		return results
	}), nil
}

// cyclonedx_dependencies Table Definition and List Function
func tableCyclonedxDependencies(ctx context.Context, tableName string) *plugin.Table {
	return &plugin.Table{
		Name:        tableName,
		Description: "Dependencies within the BOM files.",
		List: &plugin.ListConfig{
			Hydrate: listCyclonedxDependencies,
			KeyColumns: []*plugin.KeyColumn{
				{Name: "directory", Require: plugin.Optional},
			},
		},
		Columns: []*plugin.Column{
			{Name: "id", Type: proto.ColumnType_INT, Description: "ID of the dependency entry."},
			{Name: "file_id", Type: proto.ColumnType_INT, Description: "ID of the associated BOM file."},
			{Name: "directory", Type: proto.ColumnType_STRING, Description: "Directory where JSON files are located."},
			{Name: "ref", Type: proto.ColumnType_STRING, Description: "Reference of the dependency."},
		},
	}
}

func listCyclonedxDependencies(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	// Get the directory from the query or use default
	directory := getDirectory(d)

	return processAndStreamBOMData(ctx, d, directory, func(bom AutoGenerated, fileCounter, metadataCounter int, filePath string) []map[string]interface{} {
		var results []map[string]interface{}

		for _, dependency := range bom.Dependencies {
			results = append(results, map[string]interface{}{
				"id":        metadataCounter,
				"file_id":   fileCounter,
				"directory": directory,
				"ref":       dependency.Ref,
			})
			metadataCounter++
		}

		return results
	}), nil
}
